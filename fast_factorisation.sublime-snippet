<snippet>
	<content><![CDATA[
using u64 = uint64_t;
using u128 = __uint128_t;

static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

u64 pow_mod(u64 a, u64 e, u64 m) {
    u64 r = 1;
    a %= m;
    while(e) {
        if (e & 1) r = (u128)r * a % m;
        a = (u128)a * a % m;
        e >>= 1;
    }
    return r;
}

u64 prime_or_small_factor(u64 n) {
    if (n < 2) return n; 
    u64 bases[] = {2,3,5,7,11,13,17,19,23,29,31,37}; // deterministic for 64-bit
    for (u64 p : bases) {
        if (n == p) 
            return 0;           
        if (n % p == 0) 
            return (n == p ? 0 : p);
    }
    if ((n & 1ull) == 0) 
        return 2;
    // Millerâ€“Rabin
    auto is_probable_prime = [&](u64 n)->bool {
        u64 d = n - 1, s = 0;
        while ((d & 1) == 0) { d >>= 1; ++s; }
        auto witness = [&](u64 a)->bool {
            if (a % n == 0) return true;
            u64 x = pow_mod(a, d, n);
            if (x == 1 || x == n - 1) return true;
            for (u64 r = 1; r < s; ++r) {
                x = (u128)x * x % n;
                if (x == n - 1) return true;
            }
            return false;
        };
        for (u64 a : bases) 
            if (!witness(a)) return false;
        return true;
    };
    if (is_probable_prime(n)) 
        return 0;

    // minimal Pollard Rho 
    uniform_int_distribution<u64> dist_c(1, n - 1);
    uniform_int_distribution<u64> dist_x(2, n - 2);
    auto f = [&](u64 x, u64 c){ return ((u128)x * x + c) % n; };

    while(1) {
        u64 x = dist_x(rng), y = x, c = dist_c(rng), d = 1;
        while (d == 1) {
            x = f(x, c);
            y = f(f(y, c), c);
            u64 diff = x > y ? x - y : y - x;
            d = __gcd(diff, n);
        }
        if (d != n) return d; 
    }
}

]]></content>
	<tabTrigger>pollard rho</tabTrigger>
    <scope>source.c++</scope>
    <description>Fast_factorisation</description>
</snippet>
